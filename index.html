<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>History Timeline - Mochi Cards</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tufte-css/1.8.0/tufte.min.css">
    <style>
        /* Custom timeline styles that complement Tufte CSS */
        body {
            background-color: #fffff8;
        }

        .controls {
            margin: 2rem 0;
            padding: 1rem;
            background-color: #f6f6f0;
            border-left: 3px solid #333;
        }

        .controls input[type="text"], .controls textarea {
            font-family: et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
            font-size: 1.2rem;
            padding: 0.5rem;
            border: 1px solid #ccc;
            background-color: white;
            margin-right: 1rem;
            margin-bottom: 1rem;
        }

        .controls textarea {
            width: 100%;
            min-height: 200px;
            font-size: 0.9rem;
            font-family: monospace;
        }

        .controls button {
            font-family: et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
            font-size: 1.1rem;
            padding: 0.5rem 1rem;
            background-color: #333;
            color: #fffff8;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 1rem;
        }

        .controls button:hover {
            background-color: #555;
        }

        .tag-filters {
            margin: 1rem 0;
            padding: 1rem;
            background-color: #f9f9f0;
            border-left: 3px solid #999;
        }

        .tag-filter {
            display: inline-block;
            margin: 0.25rem;
            padding: 0.3rem 0.8rem;
            background-color: #333;
            color: #fffff8;
            border: 1px solid #333;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .tag-filter:hover {
            background-color: #555;
        }

        .tag-filter.inactive {
            background-color: #fffff8;
            color: #333;
            border-color: #ccc;
        }

        .tag-filter.inactive:hover {
            border-color: #333;
        }

        .filter-controls {
            margin-bottom: 1rem;
        }

        .filter-controls button {
            font-size: 0.9rem;
            padding: 0.3rem 0.8rem;
            margin-right: 0.5rem;
        }

        .instructions {
            background-color: #f9f9f0;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 3px solid #666;
        }

        .instructions code {
            background-color: #eee;
            padding: 0.2rem 0.4rem;
            font-size: 0.9rem;
        }

        .timeline-container {
            position: relative;
            margin: 3rem 0;
        }

        .timeline-line {
            position: absolute;
            left: 3rem;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #ccc;
        }

        .timeline-entry {
            position: relative;
            margin-bottom: 3rem;
            padding-left: 5rem;
        }

        .timeline-date {
            position: absolute;
            left: 0;
            top: 0;
            width: 3rem;
            text-align: right;
            font-weight: bold;
            color: #333;
        }
        
        .timeline-date small {
            font-size: 0.65rem;
            display: block;
            font-weight: normal;
            color: #666;
        }

        .timeline-dot {
            position: absolute;
            left: 3.25rem;
            top: 0.7rem;
            width: 0.5rem;
            height: 0.5rem;
            background-color: #333;
            border-radius: 50%;
        }

        .timeline-content {
            margin-left: 2rem;
        }

        .timeline-content h3 {
            font-weight: 400;
            font-style: italic;
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .timeline-description {
            font-size: 1.2rem;
            line-height: 1.6;
            color: #111;
            margin-bottom: 0.5rem;
        }

        /* Add new style for {{}} content */
        .timeline-description .highlight {
            color: #a00;
            font-weight: bold;
        }

        .timeline-tags {
            margin-top: 0.5rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.9rem;
            color: #666;
            margin-right: 1rem;
            font-style: italic;
        }

        .loading, .error {
            font-style: italic;
            color: #666;
            margin: 2rem 0;
        }

        .error {
            color: #a00;
        }

        /* Tufte-style margin notes for tags on wider screens */
        @media (min-width: 760px) {
            .timeline-entry {
                padding-right: 35%;
            }
            
            .timeline-tags {
                position: absolute;
                right: 0;
                top: 0;
                width: 30%;
                margin-top: 0;
                font-size: 0.85rem;
                line-height: 1.4;
            }
        }

        /* Animation */
        .timeline-entry {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        .tab-buttons {
            margin: 1rem 0;
        }

        .tab-button {
            background-color: #f6f6f0;
            border: 1px solid #ccc;
            padding: 0.5rem 1rem;
            cursor: pointer;
            margin-right: 0.5rem;
        }

        .tab-button.active {
            background-color: #333;
            color: #fffff8;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <article>
        <h1>History Timeline</h1>
        <p class="subtitle">A chronological view of historical events from Mochi cards</p>
        
        <section>
            <div class="instructions">
                <h2>Mochi History Timeline</h2>
                <p>This timeline displays your Mochi cards tagged with #history in chronological order.</p>
            </div>

            <div class="controls">
                <p>
                    <button onclick="loadTimelineFromAPI()">Load Timeline</button>
                    <button onclick="toggleSort()">Toggle Sort Order</button>
                    <button onclick="forceRefresh()">Force Refresh</button>
                    <button onclick="manageCacheSettings()">Cache Settings</button>
                </p>
                <div id="cacheInfo" style="font-size: 0.8rem; color: #666; margin-top: 0.5rem;"></div>
            </div>

            <div id="tagFilters" class="tag-filters" style="display: none;">
                <h3>Filter by Tags</h3>
                <div class="filter-controls">
                    <button onclick="selectAllTags()">Select All</button>
                    <button onclick="deselectAllTags()">Deselect All</button>
                </div>
                <div id="tagList"></div>
            </div>

            <div id="timeline" class="timeline-container">
                <div class="timeline-line"></div>
                <p class="loading">Loading cards from Mochi...</p>
            </div>
        </section>
    </article>

    <!-- Cache Settings Modal -->
    <div id="cacheModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000;">
        <div style="position: relative; background-color: #fffff8; margin: 10% auto; padding: 20px; width: 50%; max-width: 500px; border-left: 3px solid #333;">
            <button onclick="document.getElementById('cacheModal').style.display='none'" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>
            <h2>Cache Settings</h2>
            <div style="margin-bottom: 1rem;">
                <p>Cache Duration:</p>
                <select id="cacheDuration" style="width: 100%; padding: 0.5rem; margin-bottom: 1rem;">
                    <option value="3600000">1 Hour</option>
                    <option value="86400000">1 Day</option>
                    <option value="604800000">1 Week</option>
                    <option value="2592000000">1 Month</option>
                    <option value="-1">No Expiration</option>
                </select>
            </div>
            <div id="cacheStats" style="margin-bottom: 1rem; font-size: 0.9rem;">
                <p>Cache statistics loading...</p>
            </div>
            <div>
                <button onclick="saveAndCloseCacheSettings()" style="background-color: #333; color: white; padding: 0.5rem 1rem; border: none; margin-right: 1rem;">Save Settings</button>
                <button onclick="clearCacheAndClose()" style="background-color: #a00; color: white; padding: 0.5rem 1rem; border: none;">Clear Cache</button>
            </div>
        </div>
    </div>

    <script>
        let timelineData = [];
        let allCards = [];
        let sortAscending = true;
        let activeTags = new Set();
        
        // Cache configuration
        const CACHE_CONFIG = {
            KEY_CARDS: 'mochiCards',
            KEY_PROCESSED_CARDS: 'mochiProcessedCards',
            KEY_TIMESTAMP: 'mochiCardsTimestamp',
            KEY_DURATION: 'mochiCacheDuration',
            DEFAULT_DURATION: 24 * 60 * 60 * 1000, // 24 hours in milliseconds
        };

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }

        // Date parsing function that handles various formats
        function parseDate(dateStr) {
            if (!dateStr) return null;
            
            // Clean the string
            dateStr = dateStr.trim();
            
            // Common date patterns to try
            const patterns = [
                // Century patterns
                /(\d{1,2})(st|nd|rd|th)\s+century/i,
                // Decade patterns
                /(\d{4})s/,
                // Year ranges
                /(\d{4})\s*[-–—]\s*(\d{4})/,
                // Just year
                /^(\d{4})$/,
                /\b(\d{4})\b/,
                // Various date formats
                /(\d{1,2})\/(\d{1,2})\/(\d{4})/,
                /(\d{1,2})-(\d{1,2})-(\d{4})/,
                /(\d{4})-(\d{1,2})-(\d{1,2})/,
                /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\w*\s+(\d{1,2}),?\s+(\d{4})/i,
                /(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\w*\s+(\d{4})/i,
                // BCE/BC dates
                /(\d+)\s*(BCE|BC)/i,
                // CE/AD dates
                /(\d+)\s*(CE|AD)/i
            ];

            for (let pattern of patterns) {
                const match = dateStr.match(pattern);
                if (match) {
                    // Handle century
                    if (pattern.toString().includes('century')) {
                        const century = parseInt(match[1]);
                        return new Date((century - 1) * 100, 0, 1);
                    }
                    
                    // Handle decade
                    if (pattern.toString().includes('s/')) {
                        return new Date(parseInt(match[1]), 0, 1);
                    }
                    
                    // Handle year range (use start year)
                    if (match[2] && match[1].length === 4 && match[2].length === 4) {
                        return new Date(parseInt(match[1]), 0, 1);
                    }
                    
                    // Handle BCE dates (negative years)
                    if (match[2] && (match[2].toUpperCase() === 'BCE' || match[2].toUpperCase() === 'BC')) {
                        const yearStr = match[1].trim();
                        let year = parseInt(yearStr);
                        
                        // Handle cases like "125k BCE" that might have been missed by the k pattern
                        if (yearStr.toLowerCase().includes('k')) {
                            year = parseInt(yearStr.replace(/k/i, '')) * 1000;
                        }
                        
                        return new Date(-year, 0, 1);
                    }
                    
                    // Handle just year
                    if (match[1] && match[1].length === 4 && !match[2]) {
                        return new Date(parseInt(match[1]), 0, 1);
                    }
                    
                    // Try to parse the match normally
                    const dateObj = new Date(match[0]);
                    if (!isNaN(dateObj.getTime())) {
                        return dateObj;
                    }
                }
            }

            // Last resort: try native Date parsing
            const parsed = new Date(dateStr);
            return isNaN(parsed.getTime()) ? null : parsed;
        }

        // Extract date from card content
        function extractDateFromCard(card) {
            if (!card || !card.content) return null;

            // Split content into question and answer sections
            const sections = card.content.split('---');
            const question = sections[0];
            const answer = sections[1] || '';

            // Look for dates in both question and answer sections
            const dateMatches = [
                ...(question.match(/{{([^}]+)}}/g) || []),
                ...(answer.match(/{{([^}]+)}}/g) || []),
                // Also look for standalone years in the answer section
                ...(answer.match(/\b(\d{4})\b/g) || [])
            ];

            if (dateMatches.length === 0) return null;

            // Try each match until we find a valid date
            for (const match of dateMatches) {
                const dateStr = match.replace(/[{}]/g, '').trim();
                
                // Handle BCE dates
                if (dateStr.toLowerCase().includes('bce') || dateStr.toLowerCase().includes('bc')) {
                    // First check for 'k' notation (thousands)
                    if (dateStr.includes('k')) {
                        const yearMatch = dateStr.match(/(\d+)k/i);
                        if (yearMatch) {
                            const year = parseInt(yearMatch[1]) * 1000;
                            return new Date(-year, 0, 1);
                        }
                    }
                    
                    // Then check for regular numbers
                    const yearMatch = dateStr.match(/(\d+)/);
                    if (yearMatch) {
                        const year = parseInt(yearMatch[1]);
                        // Use negative year for BCE dates
                        return new Date(-year, 0, 1);
                    }
                }
                
                // Handle CE dates
                if (dateStr.toLowerCase().includes('ce') || dateStr.toLowerCase().includes('ad')) {
                    // First check for 'k' notation (thousands)
                    if (dateStr.includes('k')) {
                        const yearMatch = dateStr.match(/(\d+)k/i);
                        if (yearMatch) {
                            const year = parseInt(yearMatch[1]) * 1000;
                            return new Date(year, 0, 1);
                        }
                    }
                    
                    // Then check for regular numbers
                    const yearMatch = dateStr.match(/(\d+)/);
                    if (yearMatch) {
                        const year = parseInt(yearMatch[1]);
                        return new Date(year, 0, 1);
                    }
                }
                
                // Handle century dates (including "mid-Xth century")
                if (dateStr.includes('century')) {
                    // Remove any hyphens and ordinal indicators for better matching
                    const cleanStr = dateStr.replace(/-/g, '').replace(/(\d+)(st|nd|rd|th)/, '$1');
                    const centuryMatch = cleanStr.match(/(\d+)/);
                    if (centuryMatch) {
                        const century = parseInt(centuryMatch[1]);
                        const year = (century - 1) * 100;
                        // If it's "mid-Xth century", add 50 years
                        if (cleanStr.includes('mid')) {
                            return new Date(year + 50, 0, 1);
                        }
                        return new Date(year, 0, 1);
                    }
                }
                
                // Handle year ranges with k (e.g., "6k BCE" or "125k BCE")
                if (dateStr.includes('k')) {
                    const yearMatch = dateStr.match(/(\d+)k/);
                    if (yearMatch) {
                        const year = parseInt(yearMatch[1]) * 1000;
                        // Check if it's BCE
                        if (dateStr.toLowerCase().includes('bce') || dateStr.toLowerCase().includes('bc')) {
                            return new Date(-year, 0, 1);
                        }
                        return new Date(year, 0, 1);
                    }
                }
                
                // Handle approximate dates with ~
                if (dateStr.startsWith('~')) {
                    const yearMatch = dateStr.match(/~(\d+)/);
                    if (yearMatch) {
                        const year = parseInt(yearMatch[1]);
                        return new Date(year, 0, 1);
                    }
                }

                // Handle month and year combinations (e.g., "August 1945")
                const monthYearMatch = dateStr.match(/(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})/i);
                if (monthYearMatch) {
                    const month = monthYearMatch[1].toLowerCase();
                    const year = parseInt(monthYearMatch[2]);
                    const monthIndex = ['january', 'february', 'march', 'april', 'may', 'june', 
                                      'july', 'august', 'september', 'october', 'november', 'december'].indexOf(month);
                    return new Date(year, monthIndex, 1);
                }
                
                // Handle specific years
                const year = parseInt(dateStr);
                if (!isNaN(year)) {
                    return new Date(year, 0, 1);
                }
            }
            
            return null;
        }

        // Format date for display
        function formatDate(date) {
            if (!date) return 'Unknown date';
            
            const year = date.getFullYear();
            
            // Handle BCE dates
            if (year <= 0) {
                // For exact year BCE
                if (date.getMonth() === 0 && date.getDate() === 1) {
                    return `${Math.abs(year)} BCE`;
                }
                
                // For dates with month/day info in BCE
                const options = {
                    month: 'long',
                    day: 'numeric'
                };
                const monthDay = date.toLocaleDateString('en-US', options);
                return `${monthDay}, ${Math.abs(year)} BCE`;
            }
            
            // For dates with full information (CE dates)
            if (date.getMonth() !== 0 || date.getDate() !== 1) {
                return date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            }
            
            // For year-only dates (CE)
            return year.toString();
        }

        // Extract title from content
        function extractTitle(content) {
            if (!content) return 'Untitled';
            
            const lines = content.split('\n').filter(line => line.trim());
            
            // Look for first heading
            for (let line of lines) {
                if (line.startsWith('#')) {
                    return line.replace(/^#+\s*/, '');
                }
            }
            
            // Otherwise use first non-empty line
            return lines[0] || 'Untitled';
        }

        // Extract description from content
        function extractDescription(content, title) {
            if (!content) return '';
            
            // Split content into lines and remove empty lines
            const lines = content.split('\n').filter(line => line.trim());
            
            // Find the first line that's not a tag
            const descriptionLine = lines.find(line => !line.trim().startsWith('#'));
            
            if (!descriptionLine) return '';
            
            // Remove any tags from the line
            let description = descriptionLine.replace(/#\w+/g, '').trim();
            
            // Format {{}} content and remove the curly braces
            description = description.replace(/\{\{(.*?)\}\}/g, '<span class="highlight">$1</span>');
            
            return description;
        }

        async function loadTimelineFromAPI() {
            const timeline = document.getElementById('timeline');
            if (!timeline) {
                console.error('Timeline element not found');
                return;
            }

            timeline.innerHTML = '<div class="timeline-line"></div><p class="loading">Loading cards from Mochi...</p>';

            try {
                // Check if we already have processed cards in cache
                const cachedProcessedCards = localStorage.getItem(CACHE_CONFIG.KEY_PROCESSED_CARDS);
                
                if (cachedProcessedCards && isCacheValid()) {
                    try {
                        // Use cached processed cards if available and valid
                        allCards = JSON.parse(cachedProcessedCards);
                        
                        // Fix dates - JSON doesn't preserve Date objects, so we need to convert strings back to Date objects
                        allCards = allCards.map(card => {
                            if (card.parsedDate) {
                                // Handle our serialized date format (preferred)
                                if (typeof card.parsedDate === 'object' && card.parsedDate !== null) {
                                    if (card.parsedDate.hasOwnProperty('isoString') && 
                                        card.parsedDate.hasOwnProperty('timestamp')) {
                                        // Use timestamp for most accurate reconstruction
                                        card.parsedDate = new Date(card.parsedDate.timestamp);
                                    }
                                    // Fallback to year/month/day if available
                                    else if (card.parsedDate.hasOwnProperty('year') && 
                                        card.parsedDate.hasOwnProperty('month') && 
                                        card.parsedDate.hasOwnProperty('day')) {
                                        card.parsedDate = new Date(
                                            card.parsedDate.year, 
                                            card.parsedDate.month, 
                                            card.parsedDate.day
                                        );
                                    }
                                    // If it's already a proper Date instance, keep it
                                    else if (card.parsedDate instanceof Date && 
                                        typeof card.parsedDate.getFullYear === 'function') {
                                        // Nothing to do, it's already a Date
                                    }
                                    // Last resort for unrecognized object format
                                    else {
                                        try {
                                            // Try to stringify and parse
                                            card.parsedDate = new Date(JSON.stringify(card.parsedDate));
                                        } catch (e) {
                                            console.error('Could not convert date object:', card.parsedDate);
                                            throw new Error('Invalid date format in cache');
                                        }
                                    }
                                }
                                // Handle string format
                                else if (typeof card.parsedDate === 'string') {
                                    card.parsedDate = new Date(card.parsedDate);
                                }
                                // Handle number format (timestamp)
                                else if (typeof card.parsedDate === 'number') {
                                    card.parsedDate = new Date(card.parsedDate);
                                }
                                
                                // Verify the date is valid and has necessary methods
                                if (!(card.parsedDate instanceof Date) || 
                                    isNaN(card.parsedDate.getTime()) || 
                                    typeof card.parsedDate.getFullYear !== 'function') {
                                    console.error('Invalid date in cached data:', card.parsedDate);
                                    throw new Error('Invalid date in cached data');
                                }
                            } else {
                                console.error('Card has no parsedDate:', card);
                                throw new Error('Card missing parsedDate');
                            }
                            return card;
                        });
                        
                        console.log('Using cached processed cards:', allCards.length);
                        
                        // Display tag filters
                        const allTags = new Set();
                        allCards.forEach(card => {
                            if (card.tags) {
                                card.tags.forEach(tag => allTags.add(tag));
                            }
                        });
                        displayTagFilters(allTags);
                        
                        // Render timeline
                        renderTimeline(allCards);
                        
                        // Update cache info
                        updateCacheInfo();
                        
                        return;
                    } catch (error) {
                        console.error('Error using cached data:', error);
                        // Clear the corrupted cache
                        clearCache();
                        // Don't return, continue to fetch fresh data
                    }
                }
                
                // Check if we have raw cards in cache but need to process them
                let cards;
                const cachedCards = localStorage.getItem(CACHE_CONFIG.KEY_CARDS);
                
                if (cachedCards && isCacheValid()) {
                    // Use cached raw cards
                    cards = JSON.parse(cachedCards);
                    console.log('Using cached raw cards data:', cards.length);
                } else {
                    // Fetch all cards from API
                    cards = await fetchCardsFromAPI(timeline);
                    
                    // Cache the raw cards
                    if (cards && cards.length > 0) {
                        localStorage.setItem(CACHE_CONFIG.KEY_CARDS, JSON.stringify(cards));
                        localStorage.setItem(CACHE_CONFIG.KEY_TIMESTAMP, Date.now().toString());
                    }
                }
                
                if (!cards || cards.length === 0) {
                    timeline.innerHTML = '<div class="timeline-line"></div><p class="error">No cards found</p>';
                    return;
                }
                
                // Process the cards
                await processAndDisplayCards(cards, timeline);
                
                // Update cache info
                updateCacheInfo();
                
            } catch (error) {
                console.error('Error in loadTimelineFromAPI:', error);
                if (timeline) {
                    timeline.innerHTML = `<div class="timeline-line"></div><p class="error">Error loading cards: ${error.message}</p>`;
                }
            }
        }
        
        // Separate function to fetch cards from the API
        async function fetchCardsFromAPI(timeline) {
            // Fetch all cards using pagination
            const cards = [];
            let bookmark = null;
            
            while (true) {
                try {
                    // Add delay between requests to avoid rate limiting
                    if (bookmark) {
                        await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
                    }

                    const url = new URL('https://app.mochi.cards/api/cards');
                    url.searchParams.append('limit', '100');
                    if (bookmark) {
                        url.searchParams.append('bookmark', bookmark);
                    }

                    const response = await fetch(url, {
                        headers: {
                            'Authorization': 'Basic ' + btoa('e7121b3489e7ce5fac7d8fca:')
                        }
                    });

                    if (response.status === 429) {
                        // If rate limited, wait longer and retry
                        console.log('Rate limited, waiting 5 seconds...');
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        continue;
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const pageCards = data.docs || [];
                    
                    if (pageCards.length === 0) {
                        break;
                    }

                    cards.push(...pageCards);
                    console.log(`Fetched page, total cards: ${cards.length}`);
                    
                    bookmark = data.bookmark;
                    if (!bookmark) {
                        break;
                    }
                } catch (error) {
                    console.error('Error fetching cards:', error);
                    if (timeline) {
                        timeline.innerHTML = `<div class="timeline-line"></div><p class="error">Error fetching cards: ${error.message}</p>`;
                    }
                    return [];
                }
            }
            
            console.log('Total fetched cards:', cards.length);
            return cards;
        }
        
        // Separate function to process cards and display them
        async function processAndDisplayCards(cards, timeline) {
            // Filter for cards with #history tag only
            const historyCards = cards.filter(card => 
                card.tags && card.tags.some(tag => tag.toLowerCase() === 'history')
            );
            console.log('History cards:', historyCards.length);

            // Process cards to add parsed dates (this could be slow for many cards)
            allCards = historyCards.map(card => {
                const parsedDate = extractDateFromCard(card);
                const result = {
                    ...card,
                    parsedDate,
                    description: extractDescription(card.content, extractTitle(card.content))
                };
                if (!parsedDate) {
                    console.log('Card without valid date:', card.content.substring(0, 100) + '...');
                }
                return result;
            }).filter(card => card.parsedDate !== null); // Only keep cards with valid dates

            console.log('Cards with valid dates:', allCards.length);
            
            if (allCards.length > 0) {
                console.log('Date range:', {
                    earliest: allCards.reduce((min, card) => card.parsedDate < min ? card.parsedDate : min, allCards[0]?.parsedDate),
                    latest: allCards.reduce((max, card) => card.parsedDate > max ? card.parsedDate : max, allCards[0]?.parsedDate)
                });
                
                // Cache the processed cards
                // Convert Date objects to a format that can be properly reconstructed
                const serializedCards = allCards.map(card => {
                    const serializedCard = {...card};
                    if (serializedCard.parsedDate instanceof Date) {
                        // Store date as ISO string with additional metadata
                        serializedCard.parsedDate = {
                            isoString: serializedCard.parsedDate.toISOString(),
                            timestamp: serializedCard.parsedDate.getTime(),
                            year: serializedCard.parsedDate.getFullYear(),
                            month: serializedCard.parsedDate.getMonth(),
                            day: serializedCard.parsedDate.getDate()
                        };
                    }
                    return serializedCard;
                });
                
                localStorage.setItem(CACHE_CONFIG.KEY_PROCESSED_CARDS, JSON.stringify(serializedCards));
            }

            // Extract all unique tags from processed cards
            const allTags = new Set();
            allCards.forEach(card => {
                if (card.tags) {
                    card.tags.forEach(tag => allTags.add(tag));
                }
            });

            console.log('Unique tags:', Array.from(allTags).sort());
            
            // Display tag filters
            displayTagFilters(allTags);

            // Render the timeline
            if (timeline) {
                renderTimeline(allCards);
            }
        }

        // Cache management functions
        function getCacheDuration() {
            const savedDuration = localStorage.getItem(CACHE_CONFIG.KEY_DURATION);
            return savedDuration ? parseInt(savedDuration) : CACHE_CONFIG.DEFAULT_DURATION;
        }
        
        function setCacheDuration(duration) {
            localStorage.setItem(CACHE_CONFIG.KEY_DURATION, duration.toString());
            updateCacheInfo();
        }
        
        function isCacheValid() {
            const cachedData = localStorage.getItem(CACHE_CONFIG.KEY_CARDS);
            const cacheTimestamp = localStorage.getItem(CACHE_CONFIG.KEY_TIMESTAMP);
            const cacheDuration = getCacheDuration();
            
            // If cache duration is -1, it never expires
            if (cacheDuration === -1) {
                return cachedData && cacheTimestamp;
            }
            
            return cachedData && 
                   cacheTimestamp && 
                   (Date.now() - parseInt(cacheTimestamp) < cacheDuration);
        }
        
        function clearCache() {
            localStorage.removeItem(CACHE_CONFIG.KEY_CARDS);
            localStorage.removeItem(CACHE_CONFIG.KEY_PROCESSED_CARDS);
            localStorage.removeItem(CACHE_CONFIG.KEY_TIMESTAMP);
            console.log('Cache cleared');
            updateCacheInfo();
        }
        
        function updateCacheInfo() {
            const cacheInfo = document.getElementById('cacheInfo');
            if (!cacheInfo) return;
            
            const cachedData = localStorage.getItem(CACHE_CONFIG.KEY_CARDS);
            const cacheTimestamp = localStorage.getItem(CACHE_CONFIG.KEY_TIMESTAMP);
            const cacheDuration = getCacheDuration();
            
            if (!cachedData || !cacheTimestamp) {
                cacheInfo.innerHTML = 'No cached data available';
                return;
            }
            
            const lastUpdated = new Date(parseInt(cacheTimestamp));
            let expiryInfo = '';
            
            if (cacheDuration === -1) {
                expiryInfo = 'never expires';
            } else {
                const expiryTime = new Date(parseInt(cacheTimestamp) + cacheDuration);
                const now = new Date();
                
                if (expiryTime > now) {
                    // Calculate time remaining
                    const timeRemaining = expiryTime - now;
                    const hoursRemaining = Math.floor(timeRemaining / (60 * 60 * 1000));
                    const minutesRemaining = Math.floor((timeRemaining % (60 * 60 * 1000)) / (60 * 1000));
                    
                    expiryInfo = `expires in ${hoursRemaining}h ${minutesRemaining}m`;
                } else {
                    expiryInfo = 'expired';
                }
            }
            
            const dataSize = Math.round((cachedData.length / 1024) * 100) / 100;
            
            cacheInfo.innerHTML = `
                Cache: ${dataSize}KB | Last updated: ${lastUpdated.toLocaleString()} | ${expiryInfo}
            `;
        }
        
        function manageCacheSettings() {
            // Show the cache modal
            document.getElementById('cacheModal').style.display = 'block';
            
            // Set the current cache duration in the select
            const cacheDuration = getCacheDuration();
            const select = document.getElementById('cacheDuration');
            
            if (select) {
                // Try to find matching option
                const options = select.options;
                let found = false;
                
                for (let i = 0; i < options.length; i++) {
                    if (parseInt(options[i].value) === cacheDuration) {
                        select.selectedIndex = i;
                        found = true;
                        break;
                    }
                }
                
                // If no matching option, add a custom one
                if (!found && cacheDuration !== CACHE_CONFIG.DEFAULT_DURATION) {
                    const customOption = document.createElement('option');
                    customOption.value = cacheDuration;
                    
                    if (cacheDuration === -1) {
                        customOption.textContent = 'No Expiration';
                    } else {
                        customOption.textContent = `Custom (${Math.round(cacheDuration / (60 * 60 * 1000))} hours)`;
                    }
                    
                    select.appendChild(customOption);
                    select.value = cacheDuration;
                }
            }
            
            // Update cache stats
            updateCacheStats();
        }
        
        function updateCacheStats() {
            const cacheStats = document.getElementById('cacheStats');
            if (!cacheStats) return;
            
            const cachedData = localStorage.getItem(CACHE_CONFIG.KEY_CARDS);
            const cacheTimestamp = localStorage.getItem(CACHE_CONFIG.KEY_TIMESTAMP);
            const processedCards = localStorage.getItem(CACHE_CONFIG.KEY_PROCESSED_CARDS);
            
            if (!cachedData) {
                cacheStats.innerHTML = '<p>No cache data available</p>';
                return;
            }
            
            const rawCards = JSON.parse(cachedData);
            const totalCards = rawCards.length;
            const rawSize = Math.round((cachedData.length / 1024) * 100) / 100;
            let processedSize = 0;
            let historyCards = 0;
            
            if (processedCards) {
                const processed = JSON.parse(processedCards);
                historyCards = processed.length;
                processedSize = Math.round((processedCards.length / 1024) * 100) / 100;
            }
            
            const lastUpdated = cacheTimestamp ? new Date(parseInt(cacheTimestamp)).toLocaleString() : 'Unknown';
            
            cacheStats.innerHTML = `
                <p><strong>Last Updated:</strong> ${lastUpdated}</p>
                <p><strong>Total Cards:</strong> ${totalCards} (${rawSize}KB)</p>
                <p><strong>History Cards:</strong> ${historyCards} ${processedCards ? `(${processedSize}KB)` : ''}</p>
            `;
        }
        
        function saveAndCloseCacheSettings() {
            const select = document.getElementById('cacheDuration');
            if (select) {
                setCacheDuration(parseInt(select.value));
            }
            
            document.getElementById('cacheModal').style.display = 'none';
        }
        
        function clearCacheAndClose() {
            clearCache();
            document.getElementById('cacheModal').style.display = 'none';
        }
        
        // Clear cache and reload the page for a fresh start
        function clearCacheAndReload() {
            clearCache();
            window.location.reload();
        }
        
        // Force refresh the data
        async function forceRefresh() {
            clearCache();
            await loadTimelineFromAPI();
        }

        function displayTagFilters(tags) {
            const tagFiltersContainer = document.getElementById('tagFilters');
            const tagList = document.getElementById('tagList');
            
            if (tags.size === 0) {
                tagFiltersContainer.style.display = 'none';
                return;
            }

            tagFiltersContainer.style.display = 'block';
            tagList.innerHTML = '';

            // Sort tags alphabetically
            const sortedTags = Array.from(tags).sort();

            sortedTags.forEach(tag => {
                const tagElement = document.createElement('span');
                tagElement.className = 'tag-filter';
                tagElement.textContent = tag;
                tagElement.onclick = () => toggleTag(tag);
                tagList.appendChild(tagElement);
            });
        }

        function toggleTag(tag) {
            if (activeTags.has(tag)) {
                activeTags.delete(tag);
            } else {
                activeTags.add(tag);
            }
            updateTagDisplay();
            filterAndRenderTimeline();
        }

        function updateTagDisplay() {
            const tagElements = document.querySelectorAll('.tag-filter');
            tagElements.forEach(element => {
                const tag = element.textContent;
                if (activeTags.has(tag)) {
                    element.classList.remove('inactive');
                } else {
                    element.classList.add('inactive');
                }
            });
        }

        function selectAllTags() {
            const allTags = new Set();
            allCards.forEach(card => {
                if (card.tags) {
                    card.tags.forEach(tag => allTags.add(tag));
                }
            });
            activeTags = new Set(allTags);
            updateTagDisplay();
            filterAndRenderTimeline();
        }

        function deselectAllTags() {
            activeTags.clear();
            updateTagDisplay();
            filterAndRenderTimeline();
        }

        function filterAndRenderTimeline() {
            console.log('Filtering cards. Total cards:', allCards.length); // Debug log
            const filteredCards = allCards.filter(card => {
                if (!card.tags) return false;
                return card.tags.some(tag => activeTags.has(tag));
            });
            console.log('Filtered cards:', filteredCards.length); // Debug log
            
            renderTimeline(filteredCards);
        }

        function renderTimeline(cards) {
            const timeline = document.getElementById('timeline');
            timeline.innerHTML = '<div class="timeline-line"></div>';

            if (!cards || cards.length === 0) {
                timeline.innerHTML += '<p class="loading">No cards with #history tag and parseable dates found for the selected tags</p>';
                return;
            }
            
            try {
                // Verify all cards have valid parsedDate objects
                for (const card of cards) {
                    if (!card.parsedDate || !(card.parsedDate instanceof Date) || typeof card.parsedDate.getFullYear !== 'function') {
                        console.error('Invalid card date during rendering:', card);
                        throw new Error('Invalid date object found when rendering timeline');
                    }
                }
                
                // Sort by date (no need to parse dates again since they're already parsed)
                cards.sort((a, b) => {
                    return sortAscending ? 
                        a.parsedDate - b.parsedDate : 
                        b.parsedDate - a.parsedDate;
                });
            } catch (error) {
                console.error('Error during timeline rendering:', error);
                timeline.innerHTML += `
                    <p class="error">
                        Error rendering timeline: ${error.message}
                        <button onclick="clearCacheAndReload()" style="margin-left: 1rem; background-color: #a00; color: white; padding: 0.3rem 0.6rem; border: none; cursor: pointer;">
                            Clear Cache & Reload
                        </button>
                    </p>
                `;
                return;
            }

            // Group by century for better organization
            const centuries = {};
            cards.forEach(card => {
                const year = card.parsedDate.getFullYear();
                // Calculate century correctly for both BCE and CE dates
                let century;
                if (year <= 0) {
                    // For BCE: Century calculation is different
                    // -1 to -100 is 1st century BCE
                    // -101 to -200 is 2nd century BCE, etc.
                    century = Math.ceil(year / -100);
                } else {
                    // For CE: Regular calculation
                    // 1-100 is 1st century
                    // 101-200 is 2nd century, etc.
                    century = Math.ceil(year / 100);
                }
                
                // Store with BCE/CE suffix for proper sorting
                const centuryKey = year <= 0 ? `${century}BCE` : `${century}CE`;
                
                if (!centuries[centuryKey]) {
                    centuries[centuryKey] = [];
                }
                centuries[centuryKey].push(card);
            });

            // Add count to timeline
            const countInfo = document.createElement('p');
            countInfo.style.fontStyle = 'italic';
            countInfo.style.color = '#666';
            countInfo.textContent = `Showing ${cards.length} events`;
            timeline.appendChild(countInfo);

            // Helper function for ordinal suffix
            function getOrdinalSuffix(num) {
                const j = num % 10,
                      k = num % 100;
                if (j == 1 && k != 11) {
                    return num + "st";
                }
                if (j == 2 && k != 12) {
                    return num + "nd";
                }
                if (j == 3 && k != 13) {
                    return num + "rd";
                }
                return num + "th";
            }

            // Render timeline entries
            // Sort centuries chronologically (BCE to CE)
            const sortedCenturies = Object.keys(centuries).sort((a, b) => {
                const aIsBCE = a.endsWith('BCE');
                const bIsBCE = b.endsWith('BCE');
                
                if (aIsBCE && !bIsBCE) {
                    return sortAscending ? -1 : 1; // BCE comes before CE in ascending order
                }
                if (!aIsBCE && bIsBCE) {
                    return sortAscending ? 1 : -1; // CE comes after BCE in ascending order
                }
                
                // Both are BCE or both are CE
                const aNum = parseInt(a);
                const bNum = parseInt(b);
                
                if (aIsBCE && bIsBCE) {
                    // Higher numbers come first for BCE (6th century BCE before 5th century BCE)
                    return sortAscending ? bNum - aNum : aNum - bNum;
                } else {
                    // Lower numbers come first for CE (1st century before 2nd century)
                    return sortAscending ? aNum - bNum : bNum - aNum;
                }
            });
            
            sortedCenturies.forEach(centuryKey => {
                const centuryHeader = document.createElement('h2');
                const isBCE = centuryKey.endsWith('BCE');
                const cent = parseInt(centuryKey);
                
                centuryHeader.textContent = `${getOrdinalSuffix(cent)} Century ${isBCE ? 'BCE' : ''}`;
                timeline.appendChild(centuryHeader);

                centuries[centuryKey].forEach((card, index) => {
                    const entry = document.createElement('div');
                    entry.className = 'timeline-entry';
                    entry.style.animationDelay = `${index * 0.05}s`;

                    const formattedDate = formatDate(card.parsedDate);
                    const year = card.parsedDate.getFullYear();
                    const displayYear = year <= 0 ? Math.abs(year) : year;
                    
                    // Create a more informative display for the year in the timeline
                    let yearDisplay = displayYear.toString();
                    if (year <= 0) {
                        yearDisplay = `${yearDisplay}<small>BCE</small>`;
                    }

                    entry.innerHTML = `
                        <div class="timeline-date">${yearDisplay}</div>
                        <div class="timeline-dot"></div>
                        <div class="timeline-content">
                            <h3>${formattedDate}</h3>
                            <p class="timeline-description">
                                ${card.description || ''}
                            </p>
                            ${card.tags && card.tags.length > 0 ? `
                                <div class="timeline-tags">
                                    ${card.tags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                                </div>
                            ` : ''}
                        </div>
                    `;

                    timeline.appendChild(entry);
                });
            });
        }

        function toggleSort() {
            sortAscending = !sortAscending;
            if (allCards.length > 0) {
                renderTimeline(allCards);
            }
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            // Update cache info
            updateCacheInfo();
            
            // Load timeline automatically if we have valid cache
            if (isCacheValid()) {
                loadTimelineFromAPI();
            }
        });
    </script>
</body>
</html>